:_content-type: CONCEPT
:description: Importing untrusted TLS certificates to {prod-short}
:keywords: administration guide, tls, certificate
:navtitle: Importing untrusted TLS certificates to {prod-short}
:page-aliases: installation-guide:importing-untrusted-tls-certificates.adoc, installation-guide:importing-untrusted-tls-certificates-old.adoc

[id="importing-untrusted-tls-certificates"]
= Importing untrusted TLS certificates to {prod-short}

{prod-short} components communications with external services are encrypted with TLS.
They require TLS certificates signed by trusted Certificate Authorities (CA).
Therefore, you must import into {prod-short} all untrusted CA chains in use by an external service such as:

* A proxy
* An identity provider (OIDC)
* A source code repositories provider (Git)

{prod-short} uses labeled ConfigMaps in {prod-short} {orch-namespace} as sources for TLS certificates.
The ConfigMaps can have an arbitrary amount of keys with a random amount of certificates each. Operator merges all ConfigMaps into a single one titled `ca-certs-merged`, and mounts it as a volume in the {prod-short} server, dashboard and workspace pods. 
By default, the Operator mounts the `ca-certs-merged` ConfigMap in a user's workspace at two locations: `/public-certs` and `/etc/pki/ca-trust/extracted/pem`. The `/etc/pki/ca-trust/extracted/pem` directory is where the system stores extracted CA certificates for trusted certificate authorities on Red Hat (e.g., CentOS, Fedora). CLI tools automatically use certificates from the system-trusted locations, when the user's workspace is up and running.

[NOTE]
====
When an OpenShift cluster contains cluster-wide trusted CA certificates added through the link:https://docs.openshift.com/container-platform/latest/networking/configuring-a-custom-pki.html#nw-proxy-configure-object_configuring-a-custom-pki[cluster-wide-proxy configuration],
{prod-short} Operator detects them and automatically injects them into a ConfigMap with the `config.openshift.io/inject-trusted-cabundle="true"` label.
Based on this annotation, OpenShift automatically injects the cluster-wide trusted CA certificates inside the `ca-bundle.crt` key of the ConfigMap.
====

.Prerequisites
* An active `{orch-cli}` session with administrative permissions to the destination {orch-name} cluster.
See {orch-cli-link}.

* The `{prod-namespace}` {orch-namespace} exists.

* For each CA chain to import: the root CA and intermediate certificates, in link:https://wiki.openssl.org/index.php/PEM[PEM] format, in a `ca-cert-for-{prod-id-short}-__<count>__.pem` file.

.Procedure

. Concatenate all CA chains PEM files to import, into the `custom-ca-certificates.pem` file, and remove the return character that is incompatible with the Java truststore.
+
[subs="+attributes,+quotes"]
----
$ cat ca-cert-for-{prod-id-short}-*.pem | tr -d '\r' > custom-ca-certificates.pem
----

. Create the `custom-ca-certificates` ConfigMap with the required TLS certificates:
+
[subs="+attributes,+quotes"]
----
$ {orch-cli} create configmap custom-ca-certificates \
    --from-file=custom-ca-certificates.pem \
    --namespace={prod-namespace}
----

. Label the `custom-ca-certificates` ConfigMap:
+
[subs="+attributes,+quotes"]
----
$ {orch-cli} label configmap custom-ca-certificates \
    app.kubernetes.io/component=ca-bundle \
    app.kubernetes.io/part-of=che.eclipse.org \
    --namespace={prod-namespace}
----

. Deploy {prod-short} if it hasn't been deployed before.
Otherwise, wait until the rollout of {prod-short} components finishes.

. Restart running workspaces for the changes to take effect.

.Verification steps
. Verify that the ConfigMap contains your custom CA certificates.
This command returns CA bundle certificates in PEM format:
+
[subs="+attributes,+quotes",options="nowrap",role=white-space-pre]
----
$ {orch-cli} get configmap \
    --namespace={prod-namespace} \
    --output='jsonpath={.items[0:].data.custom-ca-certificates\.pem}' \
    --selector=app.kubernetes.io/component=ca-bundle,app.kubernetes.io/part-of=che.eclipse.org
----

. Verify in the {prod-short} server logs that the imported certificates count is not null:
+
[subs="+attributes,+quotes",options="nowrap",role=white-space-pre]
----
$ {orch-cli} logs deploy/{prod-id-short} --namespace={prod-namespace} \
    | grep tls-ca-bundle.pem
----

. Start a workspace, get the {orch-namespace} name in which it has been created: __<workspace_namespace>__, and wait for the workspace to be started.

. Verify that the `ca-certs-merged` ConfigMap contains your custom CA certificates.
This command returns {prod-short} CA bundle certificates in PEM format:
+
[subs="+attributes,+quotes",options="nowrap",role=white-space-pre]
----
$ {orch-cli} get configmap che-trusted-ca-certs \
    --namespace=__<workspace_namespace>__ \
    --output='jsonpath={.data.tls-ca-bundle\.pem}'
----

. Verify that the workspace pod mounts the `ca-certs-merged` ConfigMap:
+
[subs="+attributes,+quotes",options="nowrap",role=white-space-pre]
----
$ {orch-cli} get pod \
    --namespace=__<workspace_namespace>__ \
    --selector='controller.devfile.io/devworkspace_name=__<workspace_name>__' \
    --output='jsonpath={.items[0:].spec.volumes[0:].configMap.name}' \
    | grep ca-certs-merged
----

. Get the workspace pod name __<workspace_pod_name>__:
+
[subs="+attributes,+quotes",options="nowrap",role=white-space-pre]
----
$ {orch-cli} get pod \
    --namespace=__<workspace_namespace>__ \
    --selector='controller.devfile.io/devworkspace_name=__<workspace_name>__' \
    --output='jsonpath={.items[0:].metadata.name}' \
----

. Verify that the workspace container has your custom CA certificates.
This command returns {prod-short} CA bundle certificates in PEM format:
+
[subs="+attributes,+quotes",options="nowrap",role=white-space-pre]
----
$ {orch-cli} exec __<workspace_pod_name>__ \
    --namespace=__<workspace_namespace>__ \
    -- cat /public-certs/tls-ca-bundle.pem
----

.Additional resources
* xref:deploying-che-with-support-for-git-repositories-with-self-signed-certificates.adoc[].
